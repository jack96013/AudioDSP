/*
 * @Author       : TZU-CHIEH, HSU
 * @Mail         : j.k96013@gmail.com
 * @Department   : ECIE Lab, NTUT
 * @Date         : 2024-06-27 22:02:38
 * @LastEditTime : 2024-06-28 16:38:08
 * @Description  : 
 */
/*
 * @Author: TZU-CHIEH,HSU
 * @Date: 2023-08-01 20:33:25
 * @LastEditors: TZU-CHIEH,HSU
 * @LastEditTime: 2023-08-27 03:15:33
 * @Description:
 */
#include "wifiManager.h"

WifiManager::WifiManager()
{
}

void WifiManager::begin()
{
    WiFi.onEvent(std::bind(&WifiManager::WiFiEvent, std::placeholders::_1, this));
    wifiReconnectTimer = xTimerCreate("wifiTimer", pdMS_TO_TICKS(2000), pdFALSE, (void *)0, reinterpret_cast<TimerCallbackFunction_t>(this->connect));

    connect();
}

void WifiManager::check()
{
    ArduinoOTA.handle();
}

time_t WifiManager::getBootTime()
{
    return boot_time;
}

void WifiManager::connect()
{
    Serial.println("Connecting to Wi-Fi...");
    WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
}

void WifiManager::initialService()
{
    if (!MDNS.begin(DEVICE_NAME))
    {
        Serial.println("Error starting mDNS");
    }

    otaWebServer.on("/", HTTP_GET, [](AsyncWebServerRequest *request)
                    { request->send(200, "text/plain", "Hi! I am ESP32."); });
    otaWebServer.on("/reboot", HTTP_GET, [](AsyncWebServerRequest *request)
                    { request->send(200, "text/plain", "Reboot after 5s...");
                        delay(5000); 
                        ESP.restart(); });
    AsyncElegantOTA.begin(&otaWebServer); // Start ElegantOTA
    otaWebServer.begin();
    mqtt_manager.connectToMqtt();

    configTime(time_gmtOffset_sec, time_daylightOffset_sec, time_ntpServer);
    if (boot_time == 0)
    {
        struct tm timeinfo;
        if (getLocalTime(&timeinfo)) {
            time(&boot_time);
        }
    }
    initialOTA();
}

void WifiManager::initialOTA()
{
    ArduinoOTA.onStart([]()
                       {
        String type;
        if (ArduinoOTA.getCommand() == U_FLASH)
            type = "sketch";
        else // U_SPIFFS
            type = "filesystem";

        // NOTE: if updating SPIFFS this would be the place to unmount SPIFFS using SPIFFS.end()
        Serial.println("Start updating " + type); })
        .onEnd([]()
               { Serial.println("\nEnd"); })
        .onProgress([](unsigned int progress, unsigned int total)
                    { Serial.printf("Progress: %u%%\r", (progress / (total / 100))); })
        .onError([](ota_error_t error)
                 {
        Serial.printf("Error[%u]: ", error);
        if (error == OTA_AUTH_ERROR) Serial.println("Auth Failed");
        else if (error == OTA_BEGIN_ERROR) Serial.println("Begin Failed");
        else if (error == OTA_CONNECT_ERROR) Serial.println("Connect Failed");
        else if (error == OTA_RECEIVE_ERROR) Serial.println("Receive Failed");
        else if (error == OTA_END_ERROR) Serial.println("End Failed"); });

    ArduinoOTA.setHostname(DEVICE_NAME);
    // ArduinoOTA.setPassword(OTA_PASSWORD);
    ArduinoOTA.begin();
}

void WifiManager::WiFiEvent(WiFiEvent_t event, WifiManager *_this)
{
    Serial.printf("[WiFi-event] event: %d\n", event);
    switch (event)
    {
    case SYSTEM_EVENT_STA_GOT_IP:
        Serial.println("WiFi connected");
        Serial.println("IP address: ");
        Serial.println(WiFi.localIP());
        _this->initialService();
        _this->reconnnect_times = 0;
        break;
    case SYSTEM_EVENT_STA_DISCONNECTED:
        Serial.println("WiFi lost connection");
        // xTimerStop(mqttReconnectTimer, 0); // ensure we don't reconnect to MQTT while reconnecting to Wi-Fi
        xTimerStart(_this->wifiReconnectTimer, 0);
        _this->reconnnect_times ++;
        if (_this->reconnnect_times >= 10)
        {
            ESP.restart();
        }
        break;
    }
}
